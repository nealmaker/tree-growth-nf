---
title: "An FIA dataset for modeling tree-level changes in the Northern Forest"
author: "Neal Maker"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    fig_caption: TRUE
    df_print: kable
---

```{r, setup, include=FALSE}
# knitr::opts_chunk$set(echo = T, error = T, warning = T, message = T,
#                       strip.white = F, tidy.opts = list(width.cutoff = 60))
knitr::opts_chunk$set(echo = FALSE, error = FALSE, warning = FALSE,
                      message = FALSE)
```

# Introduction

The intent of this project is to put together a dataset of remeasured trees from the US Forest Service's Forest Inventory and Analysis (FIA) records for the Northern Forest region, which will allow tree-level changes to be modeled accurately. Specifically, the dataset should support the development of unbiased models of dbh increment, height, height increment, crown ratio increment, and survival; and the determination as to which variables are the most important predictors of those outcomes. Potential predictors to be kept in the dataset are those that (1) are widely available in the FIA data in the region (to maintain large sample sizes), and (2) can be recorded in forest inventories or remotely without large increases in inventory costs.

The Northern Forest region was chosen because it covers a fairly large geographic extent while still representing a coherent ecological region, in which trees can be expected to follow a similar set of behaviors. Models developed with the dataset should be relatively unbiased for individual forests within the region, but will still allow for streamlined analyses across disparate ownerships. The US Northern Forest is defined here as including Oswego, Oneida, Lewis, Jefferson, Saint Lawrence, Herkimer, Fulton, Hamilton, Franklin, Essex, Clinton, and Warren Counties in New York; Franklin, Orleans, Essex, Chittenden, Lamoille, Caledonia, Washington, Addison, Orange, and Grand Isle Counties in Vermont; Coos, Grafton, and Carroll Counties in New Hampshire; and Oxford, Franklin, Somerset, Androscoggin, Kennebec, Waldo, Hancock, Washington, Penobscot, Piscataquis, and Aroostook Counties in Maine.

```{r region}
library("tidyverse")
library("lubridate")
library("english")

# Define States & counties (FIPS codes) in Northern Forest region --------

states <- c("NY", "VT", "NH", "ME")

NY_counties <- c(75, 65, 49, 45, 89, 43, 35, 41, 33, 31, 19, 113)
VT_counties <- c(11, 19, 9, 7, 15, 5, 23, 1, 17, 13)
NH_counties <- c(7, 9, 3)
ME_counties <- c(17, 7, 25, 1, 11, 27, 9, 29, 19, 21, 3)
```

# Methods

FIA data were downloaded from the FIA DataMart^[https://apps.fs.usda.gov/fia/datamart/datamart.html] in the form of state-specific csv files, which were generated by the Forest Service from the FIA Oracle database tables. These data are current as of `r format(Sys.Date(), format = "%B %d, %Y")`. In the future, the dataset can be re-built using updated csv files to incorporate new remeasurement data.

```{r fetch}
################################################################################
# Import FIA data
################################################################################

# Fetch FIA tree, growth, plot, & condition data for Northern Forest states
# and filter to keep only northern forest counties
# (this may take a while; ~140MB of downloads + reading)

temp <- tempfile()

for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/",
                      state, "_TREE.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE.csv", sep = ""))
}

TREE <- lapply(states, function(x){
  read.csv(paste(x, "_TREE.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = ""))),
           DIAHTCD == 1) %>% # excludes seedlings measured at root collar
    select(CN, PLT_CN, SUBP, PREV_TRE_CN, CONDID, DIA, SPCD, STATUSCD,
           MORTYR, CR, CCLCD, TREECLCD, HT) %>%
    mutate(ba_ac = if_else(DIA >= 5,
                           # poles & larger from 24' radius subplots
                           # saplings from 6.8' radius microplots
                           0.005454*DIA^2*(43560/(pi*24^2)),  
                           0.005454*DIA^2*(43560/(pi*6.8^2))))
})

## SUBPLOTS MATTER!!!!
# Subplots may have different sizes depending on the plot design, found in
# PLOT$DESIGNCD (see database guide, appendix i)
# I can just keep DESIGNCD == 1 (the main standard) and lose some data,
# or I can account for the various designs when I calculate TREE$ba_ac
# (above; which would mean calculating ba_ac after combining
# states' data and joining nf_trees to nf_plots).
# Update: it's probably harder b/c they severed the plot codes to older
# inventories to keep people from seeing real coordinates

# DESIGN CODES:
# 1:4 used 1999 - present
# 11:15 used 1994 - 1996
# 100 used 1982 & 1983
# 101:104 used 1991 - 1998
# 101 was continued through 2008
# 105:120 variousy used 1991 - 1993


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_PLOT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_PLOT.csv", sep = ""))
}

PLOT <- lapply(states, function(x){
  read.csv(paste(x, "_PLOT.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>%
    select(CN, PREV_PLT_CN, DESIGNCD, MEASYEAR, MEASMON,
           MEASDAY, LAT, LON, ELEV) %>%
    rename(PLT_CN = CN)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_COND.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_COND.csv", sep = ""))
}

COND <- lapply(states, function(x){
  read.csv(paste(x, "_COND.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>%
    select(PLT_CN, CONDID, FORTYPCD, ALSTKCD, SITECLCD,
           PHYSCLCD, SLOPE, ASPECT)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_TREE_GRM_COMPONENT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}

GRM <- lapply(states, function(x){
  read.csv(paste(x, "_TREE_GRM_COMPONENT.csv", sep = ""), header = T) %>%
    select(TRE_CN, STATECD, DIA_BEGIN, DIA_MIDPT, DIA_END, ANN_DIA_GROWTH,
           HT_BEGIN, HT_MIDPT, HT_END, ANN_HT_GROWTH)
})

# Combine states' data

nf_trees <- do.call(rbind, TREE)
nf_plots <- do.call(rbind, PLOT)
nf_conds <- do.call(rbind, COND)
nf_grms <- do.call(rbind, GRM)

# delete temporary objects and downloaded files

unlink(temp)

remove(TREE, PLOT, COND, GRM, temp, state)

for(state in states){
  file.remove(paste(state, "_TREE.csv", sep = ""))
  file.remove(paste(state, "_PLOT.csv", sep = ""))
  file.remove(paste(state, "_COND.csv", sep = ""))
  file.remove(paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}
```

Records for individual trees were joined to plot and condition data to add site and stand attributes, and data from remeasured plots were joined to data from previous inventories to add starting and ending measurements. Records for trees without remeasurement data were discarded, along with records for trees that were already dead at their starting measurement, trees that were incorrectly inventoried during starting or ending inventories, and seedlings with diameters measured at the root collar instead of at breast height. FIA plot designs varied in the past in different years and locations, and we only used inventories that employed the current, standard plot design. This design started being used in the mid 1990s, and allows easy comparison between inventories from different times and places.

Some of the variables retained from the FIA tables were recorded in the field, while others were determined remotely by the FIA Program. A number of variables were also calculated after the fact in this analysis. These include plot basal area and tree overtopping basal area, which were calculated by grouping trees into their respective plots and subplots; species-specific plot basal area and overtopping basal area; species richness within subplots; coefficients of variation of dbh and height as measures of subplot structural diversity; and diameter, height, and crown ratio growth rates, which were calculated using remeasurement data. Diameter and height growth rates are also reported in the FIA database, but the FIA Program estimates diameter rates using a model instead of calculating them from the remeasurement data, making them unsuitable for training new models.

```{r bal}
################################################################################
# Group species
################################################################################

# Make names and factor levels more intuitive ------------------------------

species_codes <-
  c(12, 43, 68, 70, 71, 91, 94, 95, 96, 97, 105, 123, 125, 126, 129,
    130, 136, 202, 221, 241, 261, 310, 313, 314, 315, 316, 317, 318,
    319, 320, 331, 341, 355, 356, 357, 367, 370, 371, 372, 373, 375,
    379, 391, 400, 402, 403, 407, 409, 421, 462, 491, 500, 531, 540,
    541, 543, 544, 546, 552, 601, 602, 621, 651, 655, 660, 661, 663,
    680, 693, 701, 712, 731, 741, 742, 743, 744, 746, 760, 761, 762,
    763, 764, 771, 802, 804, 806, 816, 823, 832, 833, 837, 901, 920,
    922, 923, 926, 934, 935, 936, 937, 950, 951, 970, 972, 975, 977,
    999)

species <-
  c("fir", "other softwood", "cedar", "tamarack", "tamarack",
    "norway spruce", "spruce", "spruce", "spruce", "spruce", "other softwood",
    "other softwood", "red pine", "other softwood", "white pine", "scots pine",
    "other softwood", "other softwood", "other softwood", "cedar", "hemlock",
    "other hardwood", "soft maple", "hard maple", "striped maple", "soft maple",
    "soft maple", "hard maple", "other hardwood", "hard maple",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "other hardwood", "other hardwood", "other hardwood", "yellow birch",
    "other hardwood", "other hardwood", "paper birch", "other hardwood",
    "other hardwood", "hickory", "hickory", "hickory", "hickory", "hickory",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "beech", "ash", "ash", "ash", "ash", "ash", "other hardwood", "butternut",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "other hardwood", "hophornbeam", "other hardwood", "other hardwood",
    "aspen", "cottonwood", "aspen", "cottonwood", "aspen", "other hardwood",
    "other hardwood", "black cherry", "other hardwood", "other hardwood",
    "other hardwood", "white oak", "white oak", "red oak", "white oak",
    "white oak", "white oak", "red oak", "red oak", "other hardwood",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "other hardwood", "other hardwood", "other hardwood", "other hardwood",
    "basswood", "basswood", "elm", "elm", "elm", "elm", "other hardwood")

names(species) <- as.character(species_codes)

nf_trees$SPCD <- factor(unname(species[as.character(nf_trees$SPCD)]),
                     levels = levels(factor(species))) # standardize levels



################################################################################
# Calculate BAL & plot BA for each tree
################################################################################

# Calculates overtopping basal area (BAL) assuming all input trees are in
# same plot and ba is adjusted based on tpa:
pbal <- function(dbh, ba){
  sapply(dbh, function(x){
    index <- dbh > x
    return(sum(ba[index]))
  })
}


# Add BAL
nf_trees <- nf_trees %>%
  mutate(bal = NA,
         ba = NA)

# Note that this only calculates ending basal areas for trees that lived
nf_trees[nf_trees$STATUSCD == 1,] <- nf_trees[nf_trees$STATUSCD == 1,] %>%
  group_by(PLT_CN, SUBP) %>%
  mutate(bal = pbal(DIA, ba_ac),
         ba = sum(ba_ac, na.rm = T)) %>%
  ungroup()


################################################################################
# Calculate measures of diversity
################################################################################

# Subplot diversity, based on census of subplot trees
# Species Richness & Structural Diversity Based On DBH -------------------------
nf_trees <- nf_trees %>% 
  group_by(PLT_CN, SUBP) %>% 
  mutate(spp_rich = length(unique(SPCD)),
         dbh_var = sd(DIA, na.rm = T)/mean(DIA, na.rm = T)) %>% 
  ungroup()

# Structural Diversity Based On HT ---------------------------------------------
# can only calculate on subplots where all live trees have ht data
trees_sub <- nf_trees %>% 
  group_by(PLT_CN, SUBP) %>% 
  mutate(include = sum(!is.na(HT) & STATUSCD == 1) / 
           sum(STATUSCD == 1) == 1) %>% 
  filter(include) %>% 
  mutate(ht_var = sd(HT, na.rm = T) / mean(HT, na.rm = T)) %>% 
  ungroup() %>% 
  select(CN, ht_var)

nf_trees <- left_join(nf_trees, trees_sub, by = "CN")
  

################################################################################
# Calculate species-specific BAL & plot BA for each tree
################################################################################

# BA ---------------------------------------------------------------------------
sppba <- lapply(levels(nf_trees$SPCD), function(i) {
  temp <- nf_trees %>%
    group_by(PLT_CN, SUBP) %>%
    mutate(sppba = sum(ba_ac[SPCD == i & STATUSCD == 1])) %>%
    ungroup()
  return(temp$sppba)
})

temp <- as.data.frame(do.call(cbind, sppba))
names(temp) <- str_replace(paste0("ba_", levels(nf_trees$SPCD)), " ", ".")
nf_trees <- cbind(nf_trees, temp)


# BAL --------------------------------------------------------------------------

# Calculates overtopping basal area (BAL) of one species only, assuming all
# input trees are in same plot and ba is adjusted based on tpa:
sbal <- function(dbh, ba, spp, stat, sppref){
  sapply(dbh, function(x){
    index <- dbh > x & spp == sppref & stat == 1
    return(sum(ba[index]))
  })
}

sppbal <- lapply(levels(nf_trees$SPCD), function(i) {
  temp <- nf_trees %>% group_by(PLT_CN, SUBP) %>%
    mutate(sppbal = sbal(DIA,
                         ba_ac,
                         spp = SPCD,
                         stat = STATUSCD,
                         sppref = i)) %>%
    ungroup()
  return(temp$sppbal)
})

temp <- as.data.frame(do.call(cbind, sppbal))
names(temp) <- str_replace(paste0("bal_", levels(nf_trees$SPCD)), " ", ".")
nf_trees <- cbind(nf_trees, temp)
```

In addition to the previously well defined variables mentioned above, a new competition index was created in hopes that it would better account for competitive effects at the neighborhood scale. It is based very loosely on the sail light index used by Charles Canham and others in the Sortie-ND simulation software (see www.sortie-nd.org/help/manuals/help/data/light_behaviors/sail_light.html) and is called the porous sail index, or PSI. Unlike the sail light index, which maps the locations of individual tree crowns to determine their effect on incoming solar radiation, the PSI quantifies the overall light-blocking ability of individual trees and uses that as a proxy for competitive effect, regardless of trees' specific locations within the plot.

To calculate PSI, a porous sail value is first assigned to every live tree in the plot. The porous sail value is proportional to the crown's total light blocking area ($B$), calculated as the sectional area of a tree's crown ($A$), based on its height ($h$) and width ($w$), multiplied by the crown density ($d$), which is the proportion of light blocked through the crown's section. 
$$B = A d = \pi d \frac{h}{2} \frac{w}{2}$$ 
Since crown height can be roughly derived from tree height ($H$) and crown ratio ($r$, expressed as a proportion) as $h = H r$, the relationship can be rewritten as 
$$B = \frac{\pi d H r w}{4}$$
Crown density and crown width are unknown, so two crude assumptions are made. The first is that the crown density is directly proportional to crown ratio, such that $d = c_1 r$, where $c_1$ is a constant. This relationship came from an examination of FIA data, and is roughly accurate. The second assumption is that the ratio of crown width to crown height is fixed across all trees, such that $w = c_2 h = c_2 H r$, where $c_2$ is a constant. This is a more problematic assumption, as different species have inherently different crown shapes, which will cause the PSI to systematically overestimate the influence of some species and underestimate the influence of others. Still, it is the best we can do without knowing crown widths, and it is no more problematic than overtopping basal area, which suffers from the same faulty assumption and is widely used. Incorporating these assumptions,
$$B = \frac{\pi c_1 H r^2 w}{4} = \frac{\pi c_1 c_2 H^2 r^3}{4}$$
The porous sail value ($P$) only needs to be proportional to the light blocking area, so
$$P = H^2r^3 \propto B$$

The porous sail index for a given tree is the sum of neighboring trees' porous sail values, weighted by their heights relative to the target tree's height. 
$$PSI_t = \sum_{i=1}^{n-1} \left(P_i \frac{H_i}{H_t}\right)$$
where $PSI$ is the porous sail index, $t$ denotes the target tree, $n$ is the number of trees in the plot, and $i$ denotes one of the $n-1$ neighboring trees.

```{r porous_sail_index}
# PSI can only be calculated on subplots where all live trees have cr and ht
trees_sub <- nf_trees %>% 
  group_by(PLT_CN, SUBP) %>% 
  mutate(include = sum(!is.na(CR) & !is.na(HT) & STATUSCD == 1) / 
           sum(STATUSCD == 1) == 1) %>% 
  ungroup() %>% 
  filter(include) %>% 
  select(-include)

# porous sail (ps) is measure of a tree's light blocking, based on the  
# crude assumptions that the ratio of crown width to height is fixed and that 
# crown density is linearly correlated with crown ratio (supported by FIA data).
trees_sub <- trees_sub %>% 
  mutate(ps = if_else(STATUSCD == 1, 
                       ((CR / 100) ^ 3) * (HT ^ 2),
                       0))


################################################################################
# Calculate PSI for each tree
################################################################################

# porous sail index (psi) is sum of trees' ps in subplot affecting target  
# tree, where ps is weighted based on height relative to target tree height.
# Function assumes trees are in same subplot:
psi <- function(ht, ps){
  sapply(1:length(ht), function(i){
    sum((ht[-i] / ht[i]) * ps[-i])
  })
}

trees_sub <- trees_sub %>% 
  group_by(PLT_CN, SUBP) %>% 
  mutate(psi = psi(HT, ps)) %>% 
  ungroup()


################################################################################
# Calculate species-specific PSI for each tree
################################################################################

# Calculates porous sail index (psi) of one species only, assuming all
# input trees are in same subplot:
psi <- function(ht, ps, spp, sppref){
  ps[spp != sppref] <- 0
  sapply(1:length(ht), function(i){
    sum((ht[-i] / ht[i]) * ps[-i])
  })
}

spppsi <- lapply(levels(nf_trees$SPCD), function(i) {
  temp <- trees_sub %>% group_by(PLT_CN, SUBP) %>%
    mutate(spppsi = psi(HT, ps, spp = SPCD, sppref = i)) %>%
    ungroup()
  return(temp$spppsi)
})

temp <- as.data.frame(do.call(cbind, spppsi))
names(temp) <- str_replace(paste0("psi_", levels(nf_trees$SPCD)), " ", ".")
trees_sub <- cbind(trees_sub, temp)


## Add new data to nf_trees ----------------------------------------------------
trees_sub <- select(trees_sub, CN, psi:psi_yellow.birch)
nf_trees <- left_join(nf_trees, trees_sub, by = "CN")

rm(trees_sub, psi, spppsi, temp)
```

```{r before_and_after}
################################################################################
# Combine FIA tables & reformat
################################################################################

# get before and after data and remeasurement period for each tree and -----
# add initial cond and plot data -------------------------------------------

nf_end <- nf_trees %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  rename(cn_e = CN,
         plt_cn_e = PLT_CN,
         condid_e = CONDID,
         dbh_e = DIA,
         statuscd_e = STATUSCD,
         mortyr_e = MORTYR,
         cr_e = CR,
         crown_class_e = CCLCD,
         tree_class_e = TREECLCD,
         MEASYEAR_E = MEASYEAR,
         MEASMON_E = MEASMON,
         MEASDAY_E = MEASDAY,
         spp_rich_e = spp_rich,
         dbh_var_e = dbh_var,
         ht_var_e = ht_var,
         ba1_e = ba,
         bal1_e = bal,
         psi1_e = psi,
         ht_e = HT,
         forest_type_e = FORTYPCD,
         stocking_e = ALSTKCD,
         site_class_e = SITECLCD,
         landscape_e = PHYSCLCD,
         slope_e = SLOPE,
         aspect_e = ASPECT,
         designcd_e = DESIGNCD) %>%
  select(-SPCD, -starts_with("ba_"), -starts_with("bal_"), 
         -starts_with("psi_"), -SUBP)

nf_start <- nf_trees %>%
  filter(CN %in% nf_end$PREV_TRE_CN) %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  rename(cn_s = CN,
         plt_cn_s = PLT_CN,
         condid_s = CONDID,
         dbh_s = DIA,
         statuscd_s = STATUSCD,
         mortyr_s = MORTYR,
         cr_s = CR,
         crown_class_s = CCLCD,
         tree_class_s = TREECLCD,
         MEASYEAR_S = MEASYEAR,
         MEASMON_S = MEASMON,
         MEASDAY_S = MEASDAY,
         spp_rich_s = spp_rich,
         dbh_var_s = dbh_var,
         ht_var_s = ht_var,
         ba1_s = ba,
         bal1_s = bal,
         psi1_s = psi,
         ht_s = HT,
         forest_type_s = FORTYPCD,
         stocking_s = ALSTKCD,
         site_class_s = SITECLCD,
         landscape_s = PHYSCLCD,
         slope_s = SLOPE,
         aspect_s = ASPECT,
         designcd_s = DESIGNCD) %>%
  select(-PREV_TRE_CN, -PREV_PLT_CN, -LAT, -LON, -ELEV)

nf_fia <- nf_end %>%
  left_join(nf_start, by = c("PREV_TRE_CN" = "cn_s")) %>%
  filter(statuscd_s == 1, # only trees that started live
         statuscd_e != 0, # remove trees that were remeasured incorrectly
         #cr_s >= 0,       # only trees that had cr at start
         designcd_s == 1, # only those with current plot design
         designcd_e == 1) %>%   
  mutate(MEASMON_E = formatC(MEASMON_E, width = 2, format = "d", flag = "0"),
         MEASMON_S = formatC(MEASMON_S, width = 2, format = "d", flag = "0"),
         MEASDAY_E = formatC(MEASDAY_E, width = 2, format = "d", flag = "0"),
         MEASDAY_S = formatC(MEASDAY_S, width = 2, format = "d", flag = "0"),
         #make month and day codes 2 digits
         date_s = ymd(paste0(MEASYEAR_S, MEASMON_S, MEASDAY_S)),
         date_e = ymd(paste0(MEASYEAR_E, MEASMON_E, MEASDAY_E))) %>%
  # remove incorrectly entered dates (eg. Feb 31)
  filter(!is.na(date_e), !is.na(date_s)) %>%
  mutate(interval = as.double(as.period(date_e - date_s), unit = "years"),
         cr_rate = (cr_e - cr_s)/interval,
         cr_mid = (cr_e + cr_s)/2,
         dbh_rate = (dbh_e - dbh_s)/interval,
         dbh_mid = (dbh_e + dbh_s)/2,
         spp_rich_mid = (spp_rich_e + spp_rich_s)/2,
         dbh_var_mid = (dbh_var_e + dbh_var_s)/2,
         ht_var_mid = (ht_var_e + ht_var_s)/2,
         ba1_mid = (ba1_e + ba1_s)/2,
         bal1_mid = (bal1_e + bal1_s)/2,
         psi1_mid = (psi1_e + psi1_s)/2,
         ht_mid = (ht_e + ht_s)/2,
         ht_rate = (ht_e - ht_s)/interval,
         status_change = case_when(statuscd_e == 1 ~ "lived",
                                   statuscd_e == 2 ~ "died",
                                   statuscd_e == 3 ~ "cut",
                                   TRUE ~ "error"),
         status_change = as.factor(status_change),
         SPCD = as.factor(SPCD),
         plt_cn_e = as.factor(plt_cn_e)) %>%
  rename(ba1_ac = ba_ac) %>%
  select(cn_e, spp = SPCD, dbh_e, dbh_rate, cr_s, cr_mid,
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s,
         tree_class_e, spp_rich_s, spp_rich_mid, spp_rich_e, dbh_var_s, 
         dbh_var_mid, dbh_var_e, ht_var_s, ht_var_mid, ht_var_e, ba1_s, 
         ba1_mid, ba1_e, bal1_s, bal1_mid, bal1_e, 
         psi1_s, psi1_mid, psi1_e, ht_s, ht_mid, ht_e, ht_rate,
         forest_type_s, forest_type_e, stocking_s, stocking_e,
         landscape_s, landscape_e, site_class_s, site_class_e,
         slope_s, slope_e, aspect_s, aspect_e, lat = LAT, lon = LON,
         elev = ELEV, date_s, date_e, interval, status_change,
         plot = plt_cn_e, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_"), starts_with("psi_")) %>%
  # mortality year was all null and was removed
  inner_join(nf_grms, by = c("cn_e" = "TRE_CN")) %>%
  # use these dbh's b/c inconsistencies have been resolved (eg. measurements at different heights)
  rename(dbh_s = DIA_BEGIN, dbh_mid = DIA_MIDPT,
         dbh_rate_fia = ANN_DIA_GROWTH, state = STATECD) %>% 
  select(-ANN_HT_GROWTH)


remove(nf_start, nf_end, nf_conds, nf_plots, nf_trees, nf_grms, states,
       VT_counties, NH_counties, NY_counties, ME_counties, pbal, state,
       sppba, sppbal, temp, species, species_codes, sbal)
```

Starting and ending values were retained for variables that naturally change from one measurement to another, and midpoint values were calculated for some variables by averaging the starting and ending values. Midpoint values were recorded to better reflect average conditions during the remeasurement period.

Some of the ostensibly fixed variables like slope, aspect, and site class were found to change from one measurement to another in a minority of instances. For example, aspect was recorded differently in `r ifelse(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)) >= 10,round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, slope was recorded differently in `r ifelse(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, and site class was recorded differently in `r ifelse(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, despite the fact that they were measured on the same plots and should have remained constant. The differences between starting and ending values are generally small, however, and are probably measurement errors. In the case of slope, the mean absolute difference of deviating measurements is only `r ifelse(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)))` percent. Among erroneous site class measures, the average is only `r ifelse(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)))` site class.  Aspect errors tend to be higher, averaging `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)) >= 10, round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)), english::words(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T))))` degrees, but they can be attributed to the difficulty of determining aspects in relatively flat terrain.  If only plots with slopes over 20 percent are considered, the mean absolute aspect error falls to `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)))` degrees. All these discontinuities were assumed to be random measurement errors, and starting values were arbitrarily retained in the dataset while ending values were discarded.

```{r fixed_vars}
# Keep starting values for fixed variables & ------------------------------
# only keep records with all necessary fields ----------------------------

nf_fia <- nf_fia %>%
  rename(landscape = landscape_s,
         site_class = site_class_s,
         slope = slope_s,
         aspect = aspect_s) %>%
  select(-landscape_e, -site_class_e, -slope_e, -aspect_e)
```

Variables in the dataset were renamed and FIA codes for the levels of categorical variables were replaced with descriptive strings, to make them more intuitive and user-friendly. Tree species were also grouped into species groups and FIA forest types into more general forest types; so they match common inventory protocols and to facilitate the incorporation of uncommon species and forest types into growth models. For example, most species in the genus *Populus* are combined into a single "aspen" group, although cottonwoods (*Populus deltoides*) are kept in their own group because they exhibit very different growth characteristics. Similarly, the FIA forest types "balsam fir", "white spruce", "red spruce", "red spruce/balsam fir", and "black spruce" were combined into a single "Spruce-fir" group, but "northern white-cedar" was kept in its own "Cedar" group.

```{r categorical_levels}
################################################################################
# Make names and factor levels more intuitive
################################################################################

# Forest types -----------------------------------------------------------------

forest_type_codes <-
  c(101, 102, 103, 104, 105, 121, 122, 123, 124, 125, 126, 127,
    167, 171, 381, 384, 385, 401, 402, 409, 503, 505, 509, 512,
    513, 515, 516, 517, 519, 520, 701, 702, 703, 704, 705, 706,
    707, 708, 709, 801, 802, 805, 809, 901, 902, 903, 904, 905,
    962, 995, 999)

forest_types <-
  c("Red pine", "Red pine", "White pine", "Mixed softwood", "Hemlock",
    "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir",
    "Larch", "Cedar", "Mixed softwood", "Mixed softwood", "Scots pine",
    "Norway spruce", "Larch", "Pine-hardwood", "Mixedwood",
    "Pine-hardwood", "Oak-hickory", "Oak-hickory", "Oak-hickory",
    "Transition hardwood", "Transition hardwood", "Oak-hickory",
    "Transition hardwood", "Transition hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Transition hardwood",
    "Cottonwood", "Other", "Other", "Other", "Northern hardwood",
    "Northern hardwood", "Cottonwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Other", "Other",
    "Nonstocked")

names(forest_types) <- as.character(forest_type_codes)

nf_fia$forest_type_s <-
  factor(unname(forest_types[as.character(nf_fia$forest_type_s)]),
         levels = levels(factor(forest_types)))

nf_fia$forest_type_e <-
  factor(unname(forest_types[as.character(nf_fia$forest_type_e)]),
         levels = levels(factor(forest_types)))

# Landscapes -------------------------------------------------------------------

landscape_codes <- # add 19 & 33
  c(11, 12, 13, 19, 21, 22, 23, 24, 25, 29, 31, 32, 33, 34, 39)

landscapes <-
  c("dry tops", "dry slopes", "deep sands", "other xeric", "flatwoods",
    "rolling uplands", "moist slopes & coves", "narrow floodplains/bottomlands",
    "broad floodplains/bottomlands", "other mesic", "swamps/bogs",
    "small drains", "small drains", "beaver ponds", "other hydric")

names(landscapes) <- as.character(landscape_codes)

nf_fia$landscape <- factor(unname(landscapes[as.character(nf_fia$landscape)]),
                           levels = levels(factor(landscapes)))
```

# Missing Values

Examination of the data showed that some `r round(100 * (sum(is.na(nf_fia)) / (ncol(nf_fia) * nrow(nf_fia))), 1)`% of the values were missing. The missing values were associated with only a fraction of the variables, depicted in the following table.

```{r na}
vars_na <- 
  data.frame(variable = names(nf_fia),  
             n_NA = colSums(is.na(nf_fia)),
             pct_NA = round(colMeans(is.na(nf_fia))*100, 2),
             row.names = NULL) %>% 
  arrange(desc(n_NA)) %>% 
  filter(n_NA > 0) 

knitr::kable(vars_na, col.names = c("Variable", "Missing", "% Missing"))
```

Most of these missing values are associated with porous sail indexes and heights. The FIA program only records heights on a random subset of observations, and the porous sail index can only be calculated on plots in which all live trees have height measurements. So while these missing values limit the amount of data available for training growth models, they are random omissions and should not introduce bias. 

Many of the remaining missing values are mid-interval or end-of-interval values that are missing because the trees died. Across all the data, `r sum(nf_fia$status_change != "lived")` trees died during the remeasurement interval, and these correspond perfectly with the mid-interval and end-of-interval bal missing values. Mid-interval and end-of-interval crown ratio values are also missing for all trees that died, though they are also missing for a small number of trees that lived. End-of-interval dbh values are missing for many of the trees that died, but are present for some of them because they were estimated from stump diameters by the FIA program.

A small number of observations are missing values for other variables too, like ending forest types and stocking, and these appear to be random recording errors that can be safely removed without introducing bias.

```{r save}
################################################################################
# Finish up
################################################################################

nf_fia <- nf_fia %>% 
  filter(!is.na(spp), # only keep records with all neccessary fields
         !is.na(dbh_s), # these could affect some trees in a plot, but not all.
         !is.na(cr_s),
         !is.na(crown_class_s),
         !is.na(tree_class_s),
         !is.na(ba1_s),
         !is.na(bal1_s),
         !is.na(forest_type_s),
         !is.na(forest_type_e),
         !is.na(stocking_s),
         !is.na(stocking_e),
         !is.na(landscape),
         !is.na(site_class),
         !is.na(slope),
         !is.na(aspect),
         !is.na(lat),
         !is.na(lon),
         !is.na(elev),
         !is.na(status_change),
         xor(is.na(bal1_e), status_change == "lived"))

remove(forest_type_codes, forest_types, landscape_codes, landscapes)

# put columns in order
nf_fia <- nf_fia %>%
  select(spp, dbh_s, dbh_mid, dbh_e, dbh_rate, dbh_rate_fia, cr_s, cr_mid,
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s,
         tree_class_e, spp_rich_s, spp_rich_mid, spp_rich_e, dbh_var_s,
         dbh_var_mid, dbh_var_e, ht_var_s, ht_var_mid, ht_var_e, ba1_s, 
         ba1_mid, ba1_e, bal1_s, bal1_mid, bal1_e, psi1_s, psi1_mid, psi1_e, 
         ht_s, ht_mid, ht_e, ht_rate, forest_type_s, forest_type_e,
         stocking_s, stocking_e, landscape, site_class, slope, aspect,
         lat, lon, elev, state, date_s, date_e, interval, status_change,
         plot, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_"), starts_with("psi_")) %>%
  rename(ba_s = ba1_s, ba_mid = ba1_mid, ba_e = ba1_e,
         bal_s = bal1_s, bal_mid = bal1_mid, bal_e = bal1_e,
         psi_s = psi1_s, psi_mid = psi1_mid, psi_e = psi1_e,
         ba_ac = ba1_ac)


# Save ---------------------------------------------------------------------

save(nf_fia, file = "../data/nf-fia.rda")
```

# Organization

The final dataset contains `r format(nrow(nf_fia),big.mark=",")` unique tree records, which were tallied across `r format(length(unique(nf_fia$plot)),big.mark=",")` plots evenly distributed throughout the region. Tallied trees belong to `r length(unique(nf_fia$spp))` different species groups and were located in `r length(unique(c(nf_fia$forest_type_s,nf_fia$forest_type_e)))` different forest types in `r length(unique(nf_fia$landscape))` different physiographic (landscape) positions. Remeasurement periods ranged from `r round(min(nf_fia$interval),2)` to `r round(max(nf_fia$interval),2)` years and averaged `r round(mean(nf_fia$interval),2)` years. `r english::Words(round(100*nrow(dplyr::filter(nf_fia,status_change=="lived"))/nrow(nf_fia)))` percent of tallied trees lived through the remeasurement period and the remaining `r english::words(round(100*nrow(dplyr::filter(nf_fia,status_change=="died" | status_change=="cut"))/nrow(nf_fia)))` percent died.

A description of each variable in the final dataset and its source is provided below. Fields from the FIA database are referenced by their Oracle table and field names, in the form $TABLE\$FIELD$. Some of the variables account for more than one column in the dataset. Variable names amended with $\_s$ are measurements taken at the start of the remeasurement period; those amended with $\_e$ are measurements taken at the end of the remeasurement period; those amended with $\_mid$ are estimates of mid-period values, calculated by averaging the starting and ending measurements; and those amended with $\_rate$ are annual rates of change, averaged over the remeasurement period. Positive rates are increasing values, and negative rates are decreasing values.

__spp__   
\vspace{2pt}
Species or species group. Adapted from $TREE\$SPCD$.

__dbh__   
\vspace{2pt}
Diameter at breast height (4.5' above ground), measured in inches. From $TREE\$DIA$. Note that $dbh\_rate$ is calculated as $(dbh\_e - dbh\_s) / interval$ and is the preferred variable for model formulation. $dbh\_rate\_fia$ is from $TREE\_GRM\_COMPONENT\$ANN\_DIA\_GROWTH$ and is estimated using an existing diameter growth model. It is included for reference only and should not be used to train new models.

__cr__   
\vspace{2pt}
Compacted crown ratio (percent of tree height supporting live crown). From $TREE\$CR$.

__crown_class__   
\vspace{2pt}
Tree canopy position. From $TREE\$CCLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Open grown (crown has received full light for most or all of its life)   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Dominant (crown extends above main canopy and receives full light from above and partly from sides)   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Codominant (crown in main canopy and receives full light from above, but little from sides)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Intermediate (crown extends into main canopy, but receives little direct light)    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Overtopped (crown entirely below main canopy level, receiving no direct light)  

__tree_class__   
\vspace{2pt}
General quality of a live tree. From $TREE\$TREECLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*2* Growing-stock (of commercial species and meeting minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*3* Rough-cull (sound wood, but does not meet minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Rotten-cull (does not meet minimum merchantability standards and more than half of cull is rotten)  

__spp_rich__   
\vspace{2pt}
Subplot species richness, calculated as the total number of unique species occurring on each subplot.

__dbh_var__   
\vspace{2pt}
Coefficient of variation of trees' diameters at breast height within each subplot, used as a measure of structural diversity. Calculated by dividing the standard deviation of diameters by their mean. 

__ht_var__   
\vspace{2pt}
Coefficient of variation of trees' heights within each subplot, used as a measure of structural diversity. Calculated by dividing the standard deviation of heights by their mean. 

__ba__  
\vspace{2pt}
Plot basal area, measured in square feet per acre of all live trees, 1" dbh or greater. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then summing those basal areas within subplots. Variables whose names end with a species name (such as $ba\_ash$) are plot basal areas of only the species indicated.

__bal__   
\vspace{2pt}
Overtopping basal area, measured in square feet per acre. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then for each tree summing the per acre basal areas of other trees in in the same subplot with larger diameters. Variables whose names end with a species name (such as $bal\_ash$) are overtopping basal areas that only account for overtopping trees of the species indicated.

__psi__   
\vspace{2pt}
Porous sail index, whose computation is described in the 'Methods' section above. Variables whose names end with a species name (such as $psi\_ash$) are porous sail indexes that only account for trees of the species indicated.

__ht__   
\vspace{2pt}
Total tree height, measured in feet. From $TREE\$HT$. For trees with broken tops, heights are estimated by FIA program.

__forest_type__   
\vspace{2pt}
Forest type defined by the species dominating stocking. Adapted from $COND\$FORTYPCD$. Note that FIA does not recognize a "mixedwood" forest type, so plots with greater than half of their basal area in softwood species are generally considered softwood types, and those with greater than half of their stocking in hardwoods are considered hardwood types. The exceptions are the "Pine-hardwood" and "Cedar-hardwood" types. The forest types used here do not always coincide well with available stocking charts. Types in the Northern Forest region include:   
&nbsp;&nbsp;&nbsp;&nbsp;*Northern hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Transition hardwood*    
&nbsp;&nbsp;&nbsp;&nbsp;*Oak-hickory*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cottonwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Pine-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Spruce-fir*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar*  
&nbsp;&nbsp;&nbsp;&nbsp;*Hemlock*  
&nbsp;&nbsp;&nbsp;&nbsp;*Larch* (includes tamarack)  
&nbsp;&nbsp;&nbsp;&nbsp;*Norway spruce*  
&nbsp;&nbsp;&nbsp;&nbsp;*White pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Red pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Scots pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Mixed softwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Other*  
&nbsp;&nbsp;&nbsp;&nbsp;*Nonstocked*  

__stocking__  
\vspace{2pt}
Plot-level stocking of all live trees 1" dbh and larger. From $COND\$ALSTKCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Overstocked   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Fully stocked   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Medium stocked  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Poorly stocked    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Nonstocked   

__landscape__  
\vspace{2pt}
Physiography. From $COND\$PHYSCLCD$. Depends on land form, topographic position, and soil type.  Classes include:   
&nbsp;&nbsp;&nbsp;&nbsp;*dry tops*  
&nbsp;&nbsp;&nbsp;&nbsp;*dry slopes*  
&nbsp;&nbsp;&nbsp;&nbsp;*deep sands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other xeric*  
&nbsp;&nbsp;&nbsp;&nbsp;*flatwoods*  
&nbsp;&nbsp;&nbsp;&nbsp;*rolling uplands*  
&nbsp;&nbsp;&nbsp;&nbsp;*moist slopes & coves*  
&nbsp;&nbsp;&nbsp;&nbsp;*narrow floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*broad floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other mesic*  
&nbsp;&nbsp;&nbsp;&nbsp;*swamps/bogs*  
&nbsp;&nbsp;&nbsp;&nbsp;*small drains*  
&nbsp;&nbsp;&nbsp;&nbsp;*beaver ponds*  
&nbsp;&nbsp;&nbsp;&nbsp;*other hydric*  

__site_class__  
\vspace{2pt}
Site productivity class. From $COND\$SITECLCD$. Defined by potential wood growth in cubic feet per acre per year:   
&nbsp;&nbsp;&nbsp;&nbsp;*1* 225+ ft^3^ac^-1^yr^-1^  
&nbsp;&nbsp;&nbsp;&nbsp;*2* 165-224 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*3* 120-164 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*4* 85-119 ft^3^ac^-1^yr^-1^ (equivalent to class I in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*5* 50-84 ft^3^ac^-1^yr^-1^ (equivalent to class II in VT)  
&nbsp;&nbsp;&nbsp;&nbsp;*6* 20-49 ft^3^ac^-1^yr^-1^ (equivalent to class III in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*7* 0-19 ft^3^ac^-1^yr^-1^ (equivalent to class IV in VT)  

__slope__  
\vspace{2pt}
Slope in percent. From $COND\$SLOPE$.

__aspect__  
\vspace{2pt}
Aspect in degrees. From $COND\$ASPECT$.

__lat__  
\vspace{2pt}
Plot latitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LAT$.

__lon__  
\vspace{2pt}
Plot longitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LON$.

__elev__  
\vspace{2pt}
Plot elevation in feet above mean sea level. From $PLOT\$ELEV$.

__date__  
\vspace{2pt}
Inventory date. Calculated from $PLOT\$MEASYEAR$, $PLOT\$MEASMON$, and $PLOT\$MEASDAY$.

__interval__  
\vspace{2pt}
Length of remeasurement period in years. Calculated as $date\_e - date\_s$.

__status_change__  
\vspace{2pt}
Change in tree status during remeasurement period. Based on $TREE\$STATUSCD$. One of:   
&nbsp;&nbsp;&nbsp;&nbsp;*lived*  
&nbsp;&nbsp;&nbsp;&nbsp;*died* (natural mortality)  
&nbsp;&nbsp;&nbsp;&nbsp;*cut*  

__plot__  
\vspace{2pt}
A unique identifier for the plot the tree was recorded on. Corresponds to $PLOT\$CN$ attribute for the ending inventory.
